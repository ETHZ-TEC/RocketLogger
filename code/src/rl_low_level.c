#include "rl_low_level.h"

// ---------------------------------------------- CONSTANTS----------------------------------------------------------//

unsigned int samplerates[7] = {64000,32000,16000,8000,4000,2000,1000}; // samplerates in sps

unsigned int precisions[7] = {16, 16, 24, 24, 24, 24, 24}; // ADC precisions in bit

unsigned int sizes[7] = {2, 2, 4, 4, 4, 4, 4}; // value sizes in bytes

char channel_names[10][15] = {"I1H [nA]","I1M [nA]","I1L [10pA]","V1 [uV]","V2 [uV]","I2H [nA]","I2M [nA]","I2L [10pA]","V3 [uV]","V4 [uV]"};

struct header file_header;

// ---------------------------------------------- PRU DATA ---------------------------------------------------------//

#define PRUDATALENGTH 17
unsigned int pru_data[PRUDATALENGTH];

unsigned int state;

int test_mode = 1;


// ---------------------------------------------- FUNCTIONS --------------------------------------------------------//

// ------------------------------ SIGNAL HANDLER ------------------------------ //

void sig_handler(int signo) {

	// signal generated by stop function
    if (signo == SIGQUIT) {
		// stop sampling
		rl_log("Info: stop signal received.\n");
		state = OFF;
	}

    // Ctrl+C handling
    if (signo == SIGINT) {
    	signal(signo, SIG_IGN);
    	printf("Stopping RocketLogger ...\n");
    	state = OFF;
    }
}

// ------------------------------ LOGGING FUNCTIONS ------------------------------ //

// logging does not work!! (nobody knows why ...)

int rl_log_init() {
	remove(LOG_FILE);
	FILE* file = fopen(LOG_FILE, "w+");
	if(file == NULL) {
		perror("Error creating log file");
		return -1;
	}
	fclose(file);
	return 1;
}
int rl_log(char line[]) {
	FILE* file = fopen(LOG_FILE, "a");
	if(file == NULL) {
		perror("Error opening log file");
		return -1;
	}
	fprintf(file,"%s",line);
	fflush(file);
	fclose(file);
	return 1;
}

// ------------------------------ CALIBRATION FUNCTIONS ------------------------------ //

// reset calibration
/**
 * Set all offsets to default state (0).
 * @return Indicates success.
 */
int reset_offsets() {
	int i;
	for (i=0; i< 10; i++) {
		offsets24[i] = 0;
		offsets16[i] = 0;
	}
	return 1;
}

/**
 * Set all scales to default state (1).
 * @return Indicates success.
 */
int reset_scales() {
	int i;
	for (i=0; i< 10; i++) {
		scales24[i] = 1;
		scales16[i] = 1;
	}
	return 1;
}

/**
 * Read in calibration file.
 * @return Indicates success.
 */
int read_calibration() {
	// check if calibration file existing
	if(open(CALIBRATION_FILE, O_RDWR) <= 0) {
		rl_log("Warning: no calibration file, returning uncalibrated values.\n");
		printf("Warning: no calibration file, returning uncalibrated values.\n");
		reset_offsets();
		reset_scales();
		return 1;
	}
	// open calibration file
	FILE* file = fopen(CALIBRATION_FILE, "r");
	if(file == NULL) {
		rl_log("Error: cannot open calibration file.\n");
		perror("Error opening calibration file");
		return -1;
	}
	// read values
	fread(offsets24, sizeof(int), 10, file);
	fread(scales24, sizeof(double), 10, file);
	
	// calculate values for high rates
	int i;
	for (i=0; i<10; i++) {
		offsets16[i] = offsets24[i]/256;
		scales16[i] = scales24[i]*256;
	}
	
	//close file
	fclose(file);
	return 1;
}

/**
 * Write calibration values to file.
 * @return Indicates success.
 */
int write_calibration() {
	// open calibration file
	FILE* file = fopen(CALIBRATION_FILE, "w+");
	if(file == NULL) {
		rl_log("Error: cannot open calibration file.\n");
		perror("Error opening calibration file");
		return -1;
	}
	// write values
	fwrite(offsets24, sizeof(int), 10, file);
	fwrite(scales24, sizeof(double), 10, file);
	
	//close file
	fclose(file);
	return 1;
}
	
// ------------------------------ STANDARD FUNCTIONS ------------------------------ //

/**
 * Count the number of bits set in an integer.
 * @param x
 * @return Number of bits.
 */
int count_bits(int x) {
	int MASK = 1;
	int i;
	int sum = 0;
	for (i=0;i<32;i++) {
		if ((x&MASK) > 0) {
			sum = sum + 1;
		}
		MASK = MASK << 1;
	}
	return sum;
}


/**
 * Integer division with ceiling.
 * @param n Numerator
 * @param d Denominator
 * @return Result
 */
int ceil_div(int n, int d) {
	if(n%d == d || n%d == 0) {
		return n/d;
	} else {
		return n/d + 1;
	}
}

/**
 * Non-blocking terminal I/O: Check if the user pressed "Enter".
 * TODO: remove
 * @return 1 if button pressed.
 */
int input_available() {
  struct timeval tv;
  fd_set fds;
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  FD_ZERO(&fds);
  FD_SET(STDIN_FILENO, &fds);
  select(STDIN_FILENO+1, &fds, NULL, NULL, &tv);
  return (FD_ISSET(0, &fds));
}

// ------------------------------ FILE READING/WRITING  ------------------------------ //

// reading integer from file
int read_file_value(char filename[]) {
	FILE* fp;
	unsigned int value = 0;
	fp = fopen(filename, "rt");
	if (fp < 0) {
		rl_log("Error: cannot open file.\n");
		perror("Cannot open file");
		return -1;
	}
	if(fscanf(fp, "%x", &value) < 0) {
		rl_log("Error: cannot read from file.\n");
		perror("Cannot read from file");
		return -1;
	}
	fclose(fp);
	return value;
}

// write integer to sysfs files (with system call)
int write_sys_value(char filename[], int value) {
	char command[100];
	sprintf(command, "echo %d > %s", value, filename);
	system(command);
	return 1;
}

// write string to sysfs files (with system call)
int write_sys_string(char filename[], char value[]) {
	char command[100];
	sprintf(command, "echo %s > %s", value, filename);
	system(command);
	return 1;
}

// ------------------------------ MEMORY MAP/UNMAP ------------------------------ //

// map physical memory into virtual adress space
void* memory_map(unsigned int addr, size_t size) {
	// memory file
	int fd;
	if((fd = open("/dev/mem", O_RDWR | O_SYNC)) == -1){
		rl_log("Error: cannot open linux memory_map file.\n");
		perror("Failed to open memory");
		return NULL;
    }
	
	// map shared memory into userspace
	off_t target = addr;
	void* map_base = mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, target & ~MAP_MASK);
    if(map_base == (void *) -1) {
		rl_log("Error: cannot map PRU memory.\n");
		perror("Failed to map base address");
		return NULL;
    }
		
	close(fd);
	
	return map_base;
}

// unmap the mapped memory
int memory_unmap(void* ptr, size_t size) {
	if(munmap(ptr, size) == -1) {
		rl_log("Error: cannot unmap PRU memory.\n");
		perror("Failed to unmap memory");
		return -1;
    }
    
	return 1;
}

// ------------------------------ STORE FUNCTIONS ------------------------------ //


int store_header(FILE* data, struct header* h, int binary) {
	
	if (binary == 1) {
		fwrite(h, sizeof(struct header), 1, data);
	} else {
		// information
		fprintf(data, "Header Length:,%d\n", h->header_length);
		fprintf(data, "Number Samples:,%-12d\n", h->number_samples);
		fprintf(data, "Buffer Size:,%d\n", h->buffer_size);
		fprintf(data, "Rate:,%d\n", h->rate);
		fprintf(data, "Channels:,%d\n", h->channels);
		fprintf(data, "Precision:,%d\n", h->precision);
		
		// title row
		fprintf(data,"Time");
		fprintf(data,",LOW1");
		fprintf(data,",LOW2");
		
		// channel names
		int i;
		int MASK = 1;
		for(i=0; i<NUMBERCHANNELS; i++) {
			if((h->channels & MASK) > 0) {
				fprintf(data,",%s",channel_names[i]);
			}
			MASK = MASK << 1;
		}
		fprintf(data,"\n");
	}
	
	return 1;
}

int update_sample_number(FILE* data, struct header* h, int binary) {
	
	// store file pointer position
	long pos = ftell(data);
	rewind(data);
	
	// only store header until number samples updated
	if (binary == 1) {
		fwrite(h, 2, sizeof(int), data);
	} else {
		fprintf(data, "Header Length:,%d\n", h->header_length);
		fprintf(data, "Number Samples:,%-12d\n", h->number_samples);
	}
	
	fseek(data, pos, SEEK_SET);
	
	
	return 1;
}

// buffer
int store_buffer(FILE* data, int fifo_fd, int control_fifo, void* virt_addr, int buffer_number, unsigned int samples_buffer, unsigned int size, int channels, struct timeval* current_time, int store, int binary, int webserver) {
	
	int i = 0;
	int j = 0;
	int k = 2;
	int MASK = 1;
	int num_channels = count_bits(channels);
	
	// binary data
	int line_int[12] = {0,0,0,0,0,0,0,0,0,0,0,0};
	int value_int = 0;
	
	// csv data
	char line_char[200] = "";
	char value_char[20];
	
	// webserver data
	int avg_buffer_size = samples_buffer / WEB_BUFFER_SIZE; // size of buffer to average
	float web_data[WEB_BUFFER_SIZE][NUMBER_WEB_CHANNELS];
	
	// store header
	if(buffer_number == 0 && store == 1) {
		store_header(data, &file_header, binary);
	}
	
	/*if(buffer_number == 0 && store == 1) {
		if(binary == 1) {
			store_header_bin(data, &file_header);
		} else {
			store_header_csv(data, &file_header);
		}
	}*/
	
	// store buffer
    for(i=0; i<samples_buffer; i++){
		
		// reset values
		strcpy(line_char,"\0");
		k = 2;
		MASK = 1;
		
		// store timestamp
		if (i == 0 && store == 1) {
			time_t nowtime = current_time->tv_sec;
			struct tm *nowtm = localtime(&nowtime);
			
			if (binary == 1) {
				fwrite(nowtm, 4, 9, data);
			} else {
				sprintf (value_char, "%s", ctime (&nowtime));
				value_char[strlen(value_char)-1] = '\0'; // remove \n
				strcat(line_char,value_char);
			}
		}
		
		// read status
		line_int[0] = (int) (*((int8_t *) (virt_addr)));
		line_int[1] = (int) (*((int8_t *) (virt_addr + 1)));
		virt_addr += STATUSSIZE;
		
		// read and scale values (if channel selected)
		for(j=0; j<NUMBERCHANNELS; j++) {
			if((channels & MASK) > 0) {
				if(size == 4) {
					value_int = *( (int32_t *) (virt_addr + 4*j) );
					line_int[k] = (int) (( value_int + offsets24[j] ) * scales24[j]);
				} else {
					value_int = *( (int16_t *) (virt_addr + 2*j) );
					line_int[k] = (int) (( value_int + offsets16[j] ) * scales16[j]);
				}
				k++;
			}
			MASK = MASK << 1;
		}
		virt_addr+=NUMBERCHANNELS*size;
		
		// store values to file
		if (store == 1) {
			if (binary == 1) {
				// binary
				fwrite(line_int,4,num_channels+2,data);
			} else {
				// csv
				for(j=0; j < num_channels+2; j++) {
					sprintf(value_char,",%d",line_int[j]);
					strcat(line_char, value_char);
				}
				strcat(line_char,"\n");
				fprintf(data, line_char);
			}
		}
		
		// collapse and average values for webserver
		if (webserver == 1) {
			if (i % avg_buffer_size == 0) { // only store first sample
				collapse_data(web_data[i/avg_buffer_size], line_int, channels); //collapse data to webserver buffer
				//Todo: average data
			}
		}
    }
	
	// store values for webserver
	if (webserver == 1) {
		store_web_data(fifo_fd, control_fifo, &web_data[0][0]);
	}
	
	if (store == 1) {
		// update the number of samples stored
		file_header.number_samples += samples_buffer;
		
		update_sample_number(data, &file_header, binary);
		
	}
	
	return 1;
}

// store webserver data to fifo
int store_web_data(int fifo_fd, int control_fifo, float* buffer) {
	
	// check control fifo
	int tmp;
	int check = read(control_fifo, &tmp, sizeof(int));
	
	// only write to data fifo, if webserver online
	if(check > 0) {
		check = write(fifo_fd, buffer, sizeof(float) * WEB_BUFFER_SIZE * NUMBER_WEB_CHANNELS);
	}
	
	// count number of tokens in control fifo (count will be the number of listeners) ---> not working very nice
	/*int tmp;
	int count = 0;
	int check = read(control_fifo, &tmp, sizeof(int));
	while(check > 3) {
		count++;
		check = read(control_fifo, &tmp, sizeof(int));
	}
	
	printf("Listener count: %d\n", count);
	
	// write data for every user once
	int i;
	for(i=0; i<count; i++) {
		check = write(fifo_fd, buffer, sizeof(float) * WEB_BUFFER_SIZE * NUMBER_WEB_CHANNELS);
	}*/
	
	return 1;
}

// collapse current channels for webserver plotting (always take highest selected I-channel)
void collapse_data(float* data_out, int* data_in, int channels) {
	
	int j = 2; // first two elements are status
	// specific number of channels
	int num_i1 = count_bits(channels & I1A);
	int num_i2 = count_bits(channels & I2A);
	
	// i1
	if(num_i1 != 0) {
		if ( (channels & I1L) > 0 && num_i1 == 1) {
			data_out[0] = (float)data_in[j]/100000; // conversion to uA
		} else {
			data_out[0] = (float)data_in[j]/1000;
		}
		j += num_i1;
	} else {
		data_out[0] = 0;
	}
	
	// v1,2
	if((channels & V1) > 0) {
		data_out[1] = (float)data_in[j]/1000; // conversion to mV
		j++;
	} else {
		data_out[1] = 0;
	}
	if((channels & V2) > 0) {
		data_out[2] = (float)data_in[j]/1000;
		j++;
	} else {
		data_out[2] = 0;
	}
	
	// i2
	if(num_i2 != 0) {
		if ( (channels & I2L) > 0  && num_i2 == 1) {
			data_out[3] = (float)data_in[j]/100000;
		} else {
			data_out[3] = (float)data_in[j]/1000;
		}
		j += num_i2;
	} else {
		data_out[3] = 0;
	}
	
	// v3,4
	if((channels & V3) > 0) {
		data_out[4] = (float)data_in[j]/1000;
		j++;
	} else {
		data_out[4] = 0;
	}
	if((channels & V4) > 0) {
		data_out[5] = (float)data_in[j]/1000;
	} else {
		data_out[5] = 0;
	}

}

// ToDo: use, remove?
/*void average_data(double* data_out, int* data_in, int length, int num_channels) {
	int i;
	int j;
	long temp_data[num_channels];
	
	// reset data
	for (i=0; i < num_channels; i++) {
		temp_data[i] = 0;
	}
	
	// add data
	for( i=0; i<length; i++ ) {
		for ( j=0; j<num_channels; j++) {
			temp_data[j] += (long) data_in[i*num_channels + j];
		}
	}
	for (i=0; i< num_channels; i++) {
		printf("%-10lu", temp_data[i]);
	}
	printf("\n");
	
	// divide data
	for ( j=0; j<num_channels; j++) {
		data_out[j] = (temp_data[j] / length);
	}
}*/

// meter
void print_meter(void* virt_addr, unsigned int samples_buffer, unsigned int size, int channels) {
	
	// print header
	printf("\n\n\n\n\n\n\n\n\n\nRocketLogger Meter\n\n");
	
	if ((channels & I1A) > 0 ) {
		printf("%-20s","LOW1");
	}
	if ((channels & I2A) > 0 ) {
		printf("LOW2");
	}
	printf("\n");
	
	// print status if channels selected
	if ((channels & I1A) > 0 ) {
		printf("%-20d",(int)(*((int8_t *) (virt_addr))));
	}
	if ((channels & I2A) > 0 ) {
		printf("%-20d",(int)(*((int8_t *) (virt_addr + 1))));
	}
	printf("\n\n");
	virt_addr += STATUSSIZE;
	
	int i;
	int j;
	int k;
	int MASK_NAME = 1;
	int MASK = 1;
	int avg_number = 10;
	long value;
	for(i=0; i<3; i++) {
		if((channels & MASK_NAME) > 0) {
			printf("%-20s", channel_names[i]);
		}
		MASK_NAME = MASK_NAME << 1;
	}
	printf("\n");
	
	// print i1
	for(j=0; j<3; j++) {
		value = 0;
		if((channels & MASK) > 0) {
			if(size == 4) {
				for (k=0; k<avg_number; k++) {
					value += (long) (((*((int32_t *) (virt_addr + k * (4*NUMBERCHANNELS + STATUSSIZE) + j*4))) + offsets24[j]) * scales24[j]);
				}
				value = value / (long) avg_number;
			} else {
				for (k=0; k<samples_buffer; k++) {
					value = (long) (((*((int16_t *) (virt_addr + k * (2*NUMBERCHANNELS + STATUSSIZE) + j*2))) + offsets16[j]) * scales16[j]); // do not average here
				}
			}
			printf("%-20d", (int) value); //---> for all channels!!
		}
		MASK = MASK << 1;
	}
	printf("\n\n");
	
	// print v1,2
	for(; i<5; i++) {
		if((channels & MASK_NAME) > 0) {
			printf("%-20s", channel_names[i]);
		}
		MASK_NAME = MASK_NAME << 1;
	}
	printf("\n");
	
	for(; j<5; j++) {
		value = 0;
		if((channels & MASK) > 0) {
			if(size == 4) {
				for (k=0; k<avg_number; k++) {
					value += (long) (((*((int32_t *) (virt_addr + k * (4*NUMBERCHANNELS + STATUSSIZE) + j*4))) + offsets24[j]) * scales24[j]);
				}
				value = value / (long) avg_number;
			} else {
				for (k=0; k<samples_buffer; k++) {
					value = (long) (((*((int16_t *) (virt_addr + k * (2*NUMBERCHANNELS + STATUSSIZE) + j*2))) + offsets16[j]) * scales16[j]); // do not average here
				}
			}
			printf("%-20d", (int) value);
		}
		MASK = MASK << 1;
	}
	printf("\n\n");
	
	
	// print i2
	for(; i<8; i++) {
		if((channels & MASK_NAME) > 0) {
			printf("%-20s", channel_names[i]);
		}
		MASK_NAME = MASK_NAME << 1;
	}
	printf("\n");
	
	for(; j<8; j++) {
		value = 0;
		if((channels & MASK) > 0) {
			if(size == 4) {
				for (k=0; k<avg_number; k++) {
					value += (long) (((*((int32_t *) (virt_addr + k * (4*NUMBERCHANNELS + STATUSSIZE) + j*4))) + offsets24[j]) * scales24[j]);
				}
				value = value / (long) avg_number;
			} else {
				for (k=0; k<samples_buffer; k++) {
					value = (long) (((*((int16_t *) (virt_addr + k * (2*NUMBERCHANNELS + STATUSSIZE) + j*2))) + offsets16[j]) * scales16[j]); // do not average here
				}
			}
			printf("%-20d", (int) value);
		}
		MASK = MASK << 1;
	}
	printf("\n\n");
	
	
	// print v3,4
	for(; i<10; i++) {
		if((channels & MASK_NAME) > 0) {
			printf("%-20s", channel_names[i]);
		}
		MASK_NAME = MASK_NAME << 1;
	}
	printf("\n");
	
	for(; j<10; j++) {
		value = 0;
		if((channels & MASK) > 0) {
			if(size == 4) {
				for (k=0; k<avg_number; k++) {
					value += (long) (((*((int32_t *) (virt_addr + k * (4*NUMBERCHANNELS + STATUSSIZE) + j*4))) + offsets24[j]) * scales24[j]);
				}
				value = value / (long) avg_number;
			} else {
				for (k=0; k<samples_buffer; k++) {
					value = (long) (((*((int16_t *) (virt_addr + k * (2*NUMBERCHANNELS + STATUSSIZE) + j*2))) + offsets16[j]) * scales16[j]); // do not average here
				}
			}
			printf("%-20d", (int) value);
		}
		MASK = MASK << 1;
	}
	printf("\n\n\n\n\n\n\n\n\n\n");
	//printf("\n\n\nPress Enter to quit!\n\n\n\n\n\n\n");
}


// ------------------------------  PRU FUNCTIONS ------------------------------ //

// set state to PRU
int pru_set_state(int state){
	pru_data[0] = (unsigned int) state;
	prussdrv_pru_write_memory(PRUSS0_PRU0_DATARAM, 0, pru_data, 4);
	return 1;
}

// PRU initiation
int pru_init() {
	
	// init PRU
	tpruss_intc_initdata pruss_intc_initdata = PRUSS_INTC_INITDATA;
	prussdrv_init ();
	if (prussdrv_open(PRU_EVTOUT_0) == -1) {  
		rl_log("Error: cannot open PRU.\n");
		perror("Failed to open PRU");  
		return -1;  
	}
	prussdrv_pruintc_init(&pruss_intc_initdata);
	
	// reset pru_data
	int i;
	for (i=0;i<PRUDATALENGTH;i++) {
		pru_data[i] = 0;
	}
	return 1;
}

// main sample function
int pru_sample(FILE* data, int rate, int update_rate, int number_samples, int channels, int webserver, int store, int meter, int binary) {
		
	// read calibration
	if(read_calibration() > 0) {
		rl_log("Info: calibration values loaded.\n");
	}
	
	// set up fifo for webserver data
	int fifo_fd = -1;
	int control_fifo = -1;
	
	if (webserver == 1) {
		
		// data fifo
		fifo_fd = open(FIFO_FILE, O_NONBLOCK | O_RDWR);
		if (fifo_fd < 0) {
			printf("Error: could not open FIFO.\n");
			rl_log("Error: could not open FIFO.\n");
		}
		
		// control fifo
		control_fifo = open(CONTROL_FIFO, O_NONBLOCK | O_RDWR);
		if (control_fifo < 0) {
			printf("Error: could not open control FIFO.\n");
			rl_log("Error: could not open control FIFO.\n");
		}
	}
	
	// Map the PRU's interrupts
	tpruss_intc_initdata pruss_intc_initdata = PRUSS_INTC_INITDATA;
	prussdrv_pruintc_init(&pruss_intc_initdata);
	
	// set configuration 
	if(number_samples == 0) {
		state = CONTINUOUS;
	} else {
		state = SAMPLES;
	}
	unsigned int precision = precisions[rate/256];							// precision in bit
	unsigned int size = sizes[rate/256];									// sample size in byte
	unsigned int buffer_size = samplerates[rate/256] / update_rate;			// buffer size in samples
	unsigned int buffer_size_bytes = buffer_size * (size * NUMBERCHANNELS + STATUSSIZE) + BUFFERSTATUSSIZE; // buffer size in bytes
	unsigned int buffer0_location = read_file_value(MMAP_FILE "addr");		// two buffer for switched-buffer reading
	unsigned int buffer1_location = buffer0_location + buffer_size_bytes;
	unsigned int number_buffers = ceil_div(number_samples, buffer_size);	// number of buffers needed
	
	// save file header
	if (binary == 1) {
		file_header.header_length = HEADERLENGTH;
	} else {
		file_header.header_length = HEADERLENGTH + 1;
	}
	file_header.number_samples = 0;//number_samples; // number of samples taken
	file_header.buffer_size = buffer_size;
	file_header.rate = rate;
	file_header.channels = channels;
	file_header.precision = precision;
	
	rl_log("Info: file header stored.\n");
	
	// check memory size
	unsigned int max_size = read_file_value(MMAP_FILE "size");
	if(2*buffer_size_bytes > max_size) {
		printf("Not enough memory allocated. Run:\n  rmmod uio_pruss\n  modprobe uio_pruss extram_pool_sz=0x%06x\n", 2*buffer_size_bytes);
		rl_log("Error: not enough PRU memory allocated.\n");
		state = OFF;
	}
	
	// map PRU memory into userspace
	void* map_base = memory_map(buffer0_location, MAP_SIZE); // map base placed on start of block
	void* buffer0 = map_base + ( (off_t) buffer0_location & MAP_MASK);
	void* buffer1 = buffer0 + buffer_size_bytes; 
	
	// configure PRU0
	pru_data[0] = state;
	pru_data[1] = precision;
	pru_data[2] = size;
	pru_data[3] = buffer0_location;							// memory addresses
	pru_data[4] = buffer1_location;
	pru_data[5] = buffer_size;
	pru_data[6] = number_samples;
	pru_data[7] = 9;										// number of commands
	pru_data[8] = SDATAC;
	pru_data[9] = WREG|CONFIG3|CONFIG3DEFAULT;				// write configuration
	pru_data[10] = WREG|CONFIG1|CONFIG1DEFAULT|rate;
	pru_data[11] = WREG|CH1SET|GAIN2;						// set channel gains
	pru_data[12] = WREG|CH2SET|GAIN1;
	pru_data[13] = WREG|CH3SET|GAIN1;
	pru_data[14] = WREG|CH4SET|GAIN1;
	pru_data[15] = WREG|CH5SET|GAIN1;
	pru_data[16] = RDATAC;									//automatic reading
	
	// write configuration to PRU memory
	prussdrv_pru_write_memory(PRUSS0_PRU0_DATARAM, 0, pru_data, 4*PRUDATALENGTH);
	
	rl_log("Info: PRU configured.\n");

	// run SPI on PRU0
	prussdrv_exec_program (0, PRU_CODE);

	int i;
	void* addr;
	unsigned int samples_buffer; // number of samples per buffer
	int buffer = 0;

	rl_log("Info: sampling started.\n");
	
	// continuous sampling loop
	for(i=0;(i<number_buffers && state == SAMPLES) || state == CONTINUOUS; i++) {
		
		// select current buffer
		if(i%2 == 0) {
			addr = buffer0;
		} else {
			addr = buffer1;
		}
		// select buffer size
		if(i < number_buffers-1 || number_samples % buffer_size == 0) {
			samples_buffer = buffer_size; // full buffer size
		} else {
			samples_buffer = number_samples % buffer_size;
		}
		
		// Wait for event completion from PRU
		if (test_mode == 0) {
			prussdrv_pru_wait_event (PRU_EVTOUT_0); // returns event number
		} else {
			sleep(1);
		}
		
		// create timestamp
		struct timeval current_time;
		gettimeofday(&current_time,NULL);
		current_time.tv_sec -= 1 / update_rate; // adjust with buffer latency
		
		// clear event
		prussdrv_pru_clear_event(PRU_EVTOUT_0, PRU0_ARM_INTERRUPT);
		
		// check for overrun (compare buffer  numbers)
		if (test_mode == 0) {
			buffer = *((uint32_t*) addr);
			if (buffer != i) {
				printf("Overrun! %d samples (%d buffer) lost.\n", (buffer - i) * buffer_size, buffer - i);
				rl_log("Warning: overrun, two buffer lost.\n");
				i = buffer;
			}
		}
		
		// store the buffer
		store_buffer(data, fifo_fd, control_fifo, addr+4, i, samples_buffer, size, channels, &current_time, store, binary, webserver);
		
		// print meter output
		if (meter == 1) {
			print_meter(addr + 4, samples_buffer, size, channels);
			
		}
	}
	
	if (store == 1) {
		
		printf("Stored %d samples to file.\n", file_header.number_samples);
		fflush(data);
	}
	
	// unmap memory
	memory_unmap(map_base,MAP_SIZE);
	
	// close FIFOs
	if (webserver == 1) {
		close(fifo_fd);
		close(control_fifo);
	}
	
	return 1;
	
}

// stop PRU when in continuous mode
int pru_stop() {
	// write OFF to PRU state (so PRU can clean up)
	pru_set_state(OFF);
	
	// wait for interrupt
	prussdrv_pru_wait_event (PRU_EVTOUT_0); // returns event number
	prussdrv_pru_clear_event(PRU_EVTOUT_0, PRU0_ARM_INTERRUPT); // clear event

	return 1;
}

// cleanup PRU
int pru_close() {
	
	// Disable PRU and close memory mappings 
	prussdrv_pru_disable(0);
	prussdrv_exit ();
	return 1;
}


// ------------------------------ PWM FUNCTIONS ------------------------------ //
int pwm_init() {
	// set period/duty, disable
	write_sys_value(PWM_FILE "period", 488);
	write_sys_value(PWM_FILE "duty", 244);
	write_sys_value(PWM_FILE "run", 1);
	return 1;
}


int pwm_close() {
	//write_sys_value(PWM_FILE "run", 0); // pwm is not disabled, so ADC stays in running mode -> less temperature changes
	return 1;
}


// ------------------------------ GPIO FUNCTIONS ------------------------------ //

int gpio_init() {
	// enable GPIOs via Linux sysfs, set direction
	write_sys_value(GPIO_FILE "export", 30);
	write_sys_value(GPIO_FILE "export", 60);
	write_sys_string(FHR1_FILE "direction", "out");
	write_sys_string(FHR2_FILE "direction", "out");
	write_sys_value(FHR1_FILE "value", 0);
	write_sys_value(FHR2_FILE "value", 0);
	return 1;
}

// set GPIOs to force high range (active-low)
int force_high_range(int channels) {
	if((channels & I1) > 0) {
		write_sys_value(FHR1_FILE "value", 0);
	} else {
		write_sys_value(FHR1_FILE "value", 1);
	}
		
	if((channels & I2) > 0) {
		write_sys_value(FHR2_FILE "value", 0);
	} else {
		write_sys_value(FHR2_FILE "value", 1);
	}
	
	return 1;
}

int gpio_close() {
	// disable GPIOs via Linux sysfs
	write_sys_value(GPIO_FILE "unexport", 30);
	write_sys_value(GPIO_FILE "unexport", 60);
	return 1;
}

