#include "util.h"

// channel functions
int is_current(int index) {
	if(index == I1H_INDEX || index == I1L_INDEX || index == I2H_INDEX || index == I2L_INDEX) {
		return 1;
	} else {
		return 0;
	}
}

int is_low_current(int index) {
	if(index == I1L_INDEX || index == I2L_INDEX) {
		return 1;
	} else {
		return 0;
	}
}

int count_channels(int channels[NUM_CHANNELS]) {
	int i = 0;
	int c = 0;
	for(i=0; i<NUM_CHANNELS; i++) {
		if(channels[i] > 0) {
			c++;
		}
	}
	return c;
}

int count_i_channels(int channels[NUM_CHANNELS]) {
	int i = 0;
	int c = 0;
	for(i=0; i<NUM_CHANNELS; i++) {
		if(channels[i]> 0 && is_current(i)) {
			c++;
		}
	}
	return c;
}

int count_v_channels(int channels[NUM_CHANNELS]) {
	int i = 0;
	int c = 0;
	for(i=0; i<NUM_CHANNELS; i++) {
		if(channels[i]> 0 && !is_current(i)) {
			c++;
		}
	}
	return c;
}


// TODO: move to other file

int read_status(struct rl_status* status) {
	
	// map shared memory
	int shm_id = shmget(SHMEM_STATUS_KEY, sizeof(struct rl_status), SHMEM_PERMISSIONS);
	if (shm_id == -1) {
		rl_log(ERROR, "In read_status: failed to get shared status memory id; %d message: %s", errno, strerror(errno));
		return FAILURE;
	}
	struct rl_status* shm_status = (struct rl_status*) shmat(shm_id, NULL, 0);
	
	if (shm_status == (void *) -1) {
		rl_log(ERROR, "In read_status: failed to map shared status memory; %d message: %s", errno, strerror(errno));
		return FAILURE;
	}
	
	// read status
	*status = *shm_status;
	
	// unmap shared memory
	shmdt(shm_status);
	
	return SUCCESS;
}

int write_status(struct rl_status* status) {
	
	// map shared memory
	int shm_id = shmget(SHMEM_STATUS_KEY, sizeof(struct rl_status), IPC_CREAT | SHMEM_PERMISSIONS);
	if (shm_id == -1) {
		rl_log(ERROR, "In write_status: failed to get shared status memory id; %d message: %s", errno, strerror(errno));
		return FAILURE;
	}

	struct rl_status* shm_status = (struct rl_status*) shmat(shm_id, NULL, 0);	
	if (shm_status == (void *) -1) {
		rl_log(ERROR, "In write_status: failed to map shared status memory; %d message: %s", errno, strerror(errno));
		return FAILURE;
	}
	
	// write status
	*shm_status = *status;
	
	// unmap shared memory
	shmdt(shm_status);
	
	return SUCCESS;
}


/**
 * Count the number of bits set in an integer.
 * @param x
 * @return Number of bits.
 */
int count_bits(int x) {
	int MASK = 1;
	int i;
	int sum = 0;
	for (i=0;i<32;i++) {
		if ((x&MASK) > 0) {
			sum = sum + 1;
		}
		MASK = MASK << 1;
	}
	return sum;
}


/**
 * Integer division with ceiling.
 * @param n Numerator
 * @param d Denominator
 * @return Result
 */
int ceil_div(int n, int d) {
	if(n%d == d || n%d == 0) {
		return n/d;
	} else {
		return n/d + 1;
	}
}


// ------------------------------ SIGNAL HANDLER ------------------------------ //

void sig_handler(int signo) { // TODO: combine?

	// signal generated by stop function
    if (signo == SIGQUIT) {
		// stop sampling
    	status.sampling = SAMPLING_OFF;
	}

    // Ctrl+C handling
    if (signo == SIGINT) {
    	signal(signo, SIG_IGN);
    	printf("Stopping RocketLogger ...\n");
    	status.sampling = SAMPLING_OFF;
    }
}
// TODO: allow forced Ctrl+C


// ------------------------------ FILE READING/WRITING  ------------------------------ //

// reading integer from file
int read_file_value(char filename[]) {
	FILE* fp;
	unsigned int value = 0;
	fp = fopen(filename, "rt");
	if (fp == NULL) {
		rl_log(ERROR, "failed to open file");
		return FAILURE;
	}
	if(fscanf(fp, "%x", &value) <= 0) {
		rl_log(ERROR, "failed to read from file");
		return FAILURE;
	}
	fclose(fp);
	return value;
}
